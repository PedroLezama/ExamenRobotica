<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Robot 2 GDL - Simulación</title>
  <style>
    body{font-family: Arial, Helvetica, sans-serif;display:flex;gap:18px;padding:14px}
    .panel{width:360px}
    canvas{background:#fff;border:1px solid #ccc}
    label{display:block;margin-top:8px}
    input[type=number]{width:120px}
    .btn{margin-top:8px;padding:8px 12px;border-radius:6px;border:1px solid #666;cursor:pointer;background:#eee}
    .status{margin-top:10px;padding:8px;background:#f9f9f9;border-radius:6px;border:1px solid #eee}
  </style>
</head>
<body>
  <div class="panel">
    <h3>Controles</h3>
    <div>
      <label>Posición objetivo TCP (cm)</label>
      <input id="xd" type="number" step="0.1" value="14"> X (cm)
      <input id="yd" type="number" step="0.1" value="0"> Y (cm)
      <div>
        <button id="go" class="btn">Ir instantáneamente a (xd,yd)</button>
        <button id="traj" class="btn">Generar trayectoria (t0=0 tf=20s)</button>
      </div>
      <label>Mostrar ruta punteada</label>
      <input id="showPath" type="checkbox" checked>
      <label>Seleccionar configuración</label>
      <select id="config">
        <option value="elbow_down">Codo abajo</option>
        <option value="elbow_up">Codo arriba</option>
      </select>

      <hr>
      <button id="home" class="btn">Ir a posición inicial (xi=yi=14cm, q1=90°)</button>
      <div class="status" id="info"></div>
    </div>
    <h4>Notas</h4>
    <ul>
      <li>l1 = l2 = 12 cm. Pinza = 2 cm.</li>
      <li>Si el punto está fuera del espacio de trabajo aparecerá una advertencia.</li>
      <li>La trayectoria cartesiana usa polinomio quintico para x(t), y(t) entre t0 y tf.</li>
    </ul>
  </div>

  <div>
    <canvas id="scene" width="700" height="700"></canvas>
    <div style="display:flex;gap:8px;margin-top:8px">
      <canvas id="plotQ1" width="350" height="150"></canvas>
      <canvas id="plotQ2" width="350" height="150"></canvas>
    </div>
  </div>

<script>
// Parámetros
const l1 = 12.0; // cm
const l2 = 12.0; // cm
const gripper = 2.0; // cm (herramienta)
const t0 = 0, tf = 20; // segundos

let configElbow = 'elbow_down';

const canvas = document.getElementById('scene');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const origin = {x: W/2, y: H/2};
const scale = 8; // pixels por cm (ajusta zoom)

let current = {x:14, y:0}; // cm, TCP
let q = solveIK(current.x, current.y, 'elbow_down') || {q1:Math.PI/2, q2:0};

// elementos UI
const xdIn = document.getElementById('xd');
const ydIn = document.getElementById('yd');
const goBtn = document.getElementById('go');
const trajBtn = document.getElementById('traj');
const info = document.getElementById('info');
const showPath = document.getElementById('showPath');
const cfgSel = document.getElementById('config');
const homeBtn = document.getElementById('home');

cfgSel.addEventListener('change', ()=>{configElbow = cfgSel.value; updateAndRedraw();});

goBtn.addEventListener('click', () => {
  const xd = parseFloat(xdIn.value), yd = parseFloat(ydIn.value);
  const sol = solveIK(xd, yd, configElbow);
  if(!sol){ alert('Punto fuera del espacio de trabajo.'); return; }
  // actualizar instantáneamente
  current.x = xd; current.y = yd; q = sol;
  updateAndRedraw();
});

homeBtn.addEventListener('click', ()=>{
  // xi=yi = 14 cm; q1 = 90°
  const xi = 14, yi = 14; // interpretación: xi = yi = 0.14 m = 14 cm
  xdIn.value = xi; ydIn.value = yi;
  const sol = solveIK(xi, yi, configElbow);
  if(!sol){ alert('La posición inicial está fuera del espacio de trabajo.'); return; }
  current.x = xi; current.y = yi; q = sol;
  // force q1=90deg if possible by rotating configuration
  q.q1 = Math.PI/2;
  updateAndRedraw();
});

trajBtn.addEventListener('click', ()=>{
  const xd = parseFloat(xdIn.value), yd = parseFloat(ydIn.value);
  const sol = solveIK(xd, yd, configElbow);
  if(!sol){ alert('Punto fuera del espacio de trabajo.'); return; }
  // generar polinomio quintico entre current y destino
  const samples = 300;
  const poly = quinticPath({x:current.x,y:current.y, vx:0, vy:0, ax:0, ay:0}, {x:xd,y:yd, vx:0, vy:0, ax:0, ay:0}, t0, tf);
  const path = [];
  const q1series = [], q2series = [], tseries = [];
  for(let i=0;i<=samples;i++){
    const tt = t0 + (tf-t0)*(i/samples);
    const pt = evalQuintic(poly, tt);
    path.push(pt);
    const ik = solveIK(pt.x, pt.y, configElbow);
    if(!ik){ // si algún punto intermedio sale fuera, marcarlo
      // saltar
      q1series.push(null); q2series.push(null);
    } else {
      q1series.push(ik.q1*180/Math.PI); q2series.push(ik.q2*180/Math.PI);
    }
    tseries.push(tt);
  }
  // dibujar ruta punteada y gráficas
  drawScene(path);
  plotSeries('plotQ1', tseries, q1series, 'q1 [deg]');
  plotSeries('plotQ2', tseries, q2series, 'q2 [deg]');
});

function updateAndRedraw(){
  drawScene();
  // actualizar info
  const r = Math.hypot(current.x, current.y);
  info.innerHTML = `TCP = (${current.x.toFixed(2)} cm, ${current.y.toFixed(2)} cm) — distancia ${r.toFixed(2)} cm<br>`+
                   `q1=${(q.q1*180/Math.PI).toFixed(2)}°, q2=${(q.q2*180/Math.PI).toFixed(2)}°`;
}

function drawScene(path=null){
  ctx.clearRect(0,0,W,H);
  // grid
  ctx.strokeStyle='#eee'; ctx.lineWidth=1;
  for(let x=-W/2; x<=W/2; x+=scale*2){ ctx.beginPath(); ctx.moveTo(origin.x+x,0); ctx.lineTo(origin.x+x,H); ctx.stroke(); }
  for(let y=-H/2; y<=H/2; y+=scale*2){ ctx.beginPath(); ctx.moveTo(0, origin.y+y); ctx.lineTo(W, origin.y+y); ctx.stroke(); }

  // draw workspace circle (max reach)
  const maxr = (l1 + l2 + gripper) * scale;
  ctx.beginPath(); ctx.strokeStyle='#999'; ctx.lineWidth=1.5; ctx.arc(origin.x, origin.y, maxr, 0, Math.PI*2); ctx.stroke();

  // compute joint positions
  const joint0 = {x:0,y:0};
  const p1 = {x: l1*Math.cos(q.q1), y: l1*Math.sin(q.q1)};
  const p2 = {x: p1.x + l2*Math.cos(q.q1 + q.q2), y: p1.y + l2*Math.sin(q.q1 + q.q2)};
  const tip = {x: p2.x + gripper*Math.cos(q.q1 + q.q2), y: p2.y + gripper*Math.sin(q.q1 + q.q2)};

  // optional path
  if(path && showPath.checked){
    ctx.beginPath(); ctx.setLineDash([4,6]); ctx.strokeStyle='black'; ctx.lineWidth=1.2;
    for(let i=0;i<path.length;i++){
      const pt = path[i]; const px = origin.x + pt.x*scale, py = origin.y - pt.y*scale;
      if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.stroke(); ctx.setLineDash([]);
  }

  // draw links
  const toCanvas = p=>({x: origin.x + p.x*scale, y: origin.y - p.y*scale});
  const J0 = toCanvas(joint0), J1 = toCanvas(p1), J2 = toCanvas(p2), T = toCanvas(tip);

  // link1
  ctx.beginPath(); ctx.lineWidth=8; ctx.strokeStyle='#2ca02c'; ctx.moveTo(J0.x,J0.y); ctx.lineTo(J1.x,J1.y); ctx.stroke();
  // link2
  ctx.beginPath(); ctx.lineWidth=8; ctx.strokeStyle='#ff9900'; ctx.moveTo(J1.x,J1.y); ctx.lineTo(J2.x,J2.y); ctx.stroke();
  // gripper
  ctx.beginPath(); ctx.lineWidth=6; ctx.strokeStyle='#000'; ctx.moveTo(J2.x,J2.y); ctx.lineTo(T.x,T.y); ctx.stroke();

  // joints
  [J0,J1,J2,T].forEach(pt=>{ ctx.beginPath(); ctx.fillStyle='#000'; ctx.arc(pt.x,pt.y,6,0,Math.PI*2); ctx.fill(); });

  // labels
  ctx.fillStyle='#000'; ctx.font='14px Arial'; ctx.fillText('O', J0.x+6, J0.y+16);
}

// initial draw
updateAndRedraw();

// IK: devuelve null si fuera, o {q1,q2} en rad
function solveIK(xd, yd, config='elbow_down'){
  const r = Math.hypot(xd, yd);
  // wrist position descontando la pinza (asumimos que pinza apunta hacia el mismo angulo de la segunda articulacion)
  const r_wrist = r - gripper;
  // check reachable
  const EPS=1e-6;
  if(r_wrist < Math.abs(l1 - l2) - EPS || r_wrist > (l1 + l2) + EPS) return null;
  const phi = Math.atan2(yd, xd);
  const cos_q2 = (r_wrist*r_wrist - l1*l1 - l2*l2) / (2*l1*l2);
  const q2a = Math.acos(Math.min(1,Math.max(-1, cos_q2)));
  const q2 = (config === 'elbow_down') ? -q2a : q2a; // sign to pick elbow config
  const k1 = l1 + l2*Math.cos(q2);
  const k2 = l2*Math.sin(q2);
  const q1 = phi - Math.atan2(k2, k1);
  return {q1:q1, q2:q2};
}

// Polinomio quintico para x,y con condiciones pos/v/acc inicial y final
function quinticPath(p0, p1, t0, tf){
  // generamos coeficientes para x y y por separado
  function coeffs(a0,a1,a2,af,af1,af2){
    // a0=pos0, a1=vel0, a2=acc0, af=posf, af1=velf, af2=accf
    const T = tf - t0;
    const A = [
      [Math.pow(T,3), Math.pow(T,4), Math.pow(T,5)],
      [3*Math.pow(T,2), 4*Math.pow(T,3), 5*Math.pow(T,4)],
      [6*T, 12*Math.pow(T,2), 20*Math.pow(T,3)]
    ];
    const B = [af - (a0 + a1*T + 0.5*a2*T*T), af1 - (a1 + a2*T), af2 - a2];
    // solve 3x3 (manual)
    // use Cramer's or simple linear solve
    // We'll solve using gaussian elimination (simple)
    const M = [A[0].slice(), A[1].slice(), A[2].slice()];
    const b = B.slice();
    for(let i=0;i<3;i++){
      // pivot
      let max=i; for(let j=i+1;j<3;j++) if(Math.abs(M[j][i])>Math.abs(M[max][i])) max=j;
      [M[i],M[max]]=[M[max],M[i]]; [b[i],b[max]]=[b[max],b[i]];
      const piv = M[i][i];
      for(let j=i;j<3;j++) M[i][j]/=piv; b[i]/=piv;
      for(let r=0;r<3;r++) if(r!=i){ const f=M[r][i]; for(let c=i;c<3;c++) M[r][c]-=f*M[i][c]; b[r]-=f*b[i]; }
    }
    return [a0, a1, 0.5*a2, b[0], b[1], b[2]]; // coefficients a0..a5
  }
  const cx = coeffs(p0.x, p0.vx, p0.ax, p1.x, p1.vx, p1.ax);
  const cy = coeffs(p0.y, p0.vy, p0.ay, p1.y, p1.vy, p1.ay);
  return {cx, cy};
}
function evalQuintic(poly, t){
  const dt = t - t0;
  const cx = poly.cx; const cy = poly.cy;
  const x = cx[0] + cx[1]*dt + cx[2]*dt*dt + cx[3]*Math.pow(dt,3) + cx[4]*Math.pow(dt,4) + cx[5]*Math.pow(dt,5);
  const y = cy[0] + cy[1]*dt + cy[2]*dt*dt + cy[3]*Math.pow(dt,3) + cy[4]*Math.pow(dt,4) + cy[5]*Math.pow(dt,5);
  return {x,y};
}

// dibujar gráficas simples
function plotSeries(canvasId, tseries, series, ylabel){
  const c = document.getElementById(canvasId); const g=c.getContext('2d');
  g.clearRect(0,0,c.width,c.height);
  // find min/max
  let min=Infinity,max=-Infinity; for(let v of series) if(v!=null){min=Math.min(min,v); max=Math.max(max,v);} if(min===Infinity){g.fillText('No data',10,20);return}
  const pad=10; const W=c.width-2*pad, H=c.height-2*pad;
  // axes
  g.strokeStyle='#bbb'; g.beginPath(); g.rect(pad,pad,W,H); g.stroke();
  // plot
  g.beginPath(); g.strokeStyle='#0077aa'; g.lineWidth=1.2;
  for(let i=0;i<series.length;i++){
    const v=series[i]; const t = tseries[i];
    if(v==null) { continue; }
    const x = pad + (i/(series.length-1))*W;
    const y = pad + H - ((v - min)/(max - min || 1))*H;
    if(i==0||series[i-1]==null) g.moveTo(x,y); else g.lineTo(x,y);
  }
  g.stroke();
  g.fillStyle='#000'; g.font='12px Arial'; g.fillText(ylabel, 6, 14);
}

</script>
</body>
</html>
